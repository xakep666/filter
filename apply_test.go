// Code generated by go2go; DO NOT EDIT.


//line apply_test.go2:5
package filter

//line apply_test.go2:5
import (
//line apply_test.go2:5
 "reflect"
//line apply_test.go2:5
 "testing"
//line apply_test.go2:5
)

//line apply_test.go2:12
func triple(a int) int {
	return a * 3
}

func tripleString(a string) string {
	return a + a + a
}

func tripleToFloat(a int) float64 {
	return float64(a * 3)
}

func floatToInt(a float64) int {
	return int(a)
}

func isEven(a int) bool {
	return a%2 == 0
}

func isEvenString(a string) bool {
	return a[0]%2 == 0
}

func is18(a int) bool {
	return a == 18
}

func TestApply(t *testing.T) {
	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	expect := []int{3, 6, 9, 12, 15, 18, 21, 24, 27}
	result := instantiate୦୦Apply୦int୦int(a, triple)
	if !reflect.DeepEqual(expect, result) {
		t.Fatalf("Apply failed: expect %v got %v", expect, result)
	}
}

func TestApplyString(t *testing.T) {
	a := []string{"1", "2", "3", "4", "5", "6", "7", "8", "9"}
	expect := []string{"111", "222", "333", "444", "555", "666", "777", "888", "999"}
	result := instantiate୦୦Apply୦string୦string(a, tripleString)
	if !reflect.DeepEqual(expect, result) {
		t.Fatalf("Apply failed: expect %v got %v", expect, result)
	}
}

func TestApplyDifferentTypes(t *testing.T) {
	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	expect := []int{3, 6, 9, 12, 15, 18, 21, 24, 27}
	result := instantiate୦୦Apply୦float64୦int(instantiate୦୦Apply୦int୦float64(a, tripleToFloat), floatToInt)
	if !reflect.DeepEqual(expect, result) {
		t.Fatalf("Apply failed: expect %v got %v", expect, result)
	}
}

func TestChoose(t *testing.T) {
	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	expect := []int{2, 4, 6, 8}
	result := instantiate୦୦Choose୦int(a, isEven)
	if !reflect.DeepEqual(expect, result) {
		t.Fatalf("Choose failed: expect %v got %v", expect, result)
	}
}

func TestDrop(t *testing.T) {
	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	expect := []int{1, 3, 5, 7, 9}
	result := instantiate୦୦Drop୦int(a, isEven)
	if !reflect.DeepEqual(expect, result) {
		t.Fatalf("Drop failed: expect %v got %v", expect, result)
	}
}

func TestApplyInPlace(t *testing.T) {
				a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
				expect := []int{3, 6, 9, 12, 15, 18, 21, 24, 27}
//line apply_test.go2:87
 instantiate୦୦ApplyInPlace୦int(a, triple)
//line apply_test.go2:89
 if !reflect.DeepEqual(expect, a) {
		t.Fatalf("Apply failed: expect %v got %v", expect, a)
	}
}

func TestApplyInPlaceString(t *testing.T) {
				a := []string{"1", "2", "3", "4", "5", "6", "7", "8", "9"}
				expect := []string{"111", "222", "333", "444", "555", "666", "777", "888", "999"}
//line apply_test.go2:96
 instantiate୦୦ApplyInPlace୦string(a, tripleString)
//line apply_test.go2:98
 if !reflect.DeepEqual(expect, a) {
		t.Fatalf("Apply failed: expect %v got %v", expect, a)
	}
}

func TestChooseInPlaceString(t *testing.T) {
				a := []string{"1", "2", "3", "4", "5", "6", "7", "8", "9"}
				expect := []string{"2", "4", "6", "8"}
//line apply_test.go2:105
 instantiate୦୦ChooseInPlace୦string(&a, isEvenString)
//line apply_test.go2:107
 if !reflect.DeepEqual(expect, a) {
		t.Fatalf("ChooseInPlace failed: expect %v got %v", expect, a)
	}
}

func TestDropInPlaceString(t *testing.T) {
				a := []string{"1", "2", "3", "4", "5", "6", "7", "8", "9"}
				expect := []string{"1", "3", "5", "7", "9"}
//line apply_test.go2:114
 instantiate୦୦DropInPlace୦string(&a, isEvenString)
//line apply_test.go2:116
 if !reflect.DeepEqual(expect, a) {
		t.Fatalf("DropInPlace failed: expect %v got %v", expect, a)
	}
}
//line apply.go2:19
func instantiate୦୦Apply୦int୦int(slice []int, function func(int,) int,) []int {
	out := make([]int, 0, len(slice))
	for _, v := range slice {
		out = append(out, function(v))
	}
	return out
}
//line apply.go2:19
func instantiate୦୦Apply୦string୦string(slice []string, function func(string,) string,) []string {
	out := make([]string, 0, len(slice))
	for _, v := range slice {
		out = append(out, function(v))
	}
	return out
}
//line apply.go2:19
func instantiate୦୦Apply୦float64୦int(slice []float64, function func(float64,) int,) []int {
	out := make([]int, 0, len(slice))
	for _, v := range slice {
		out = append(out, function(v))
	}
	return out
}
//line apply.go2:19
func instantiate୦୦Apply୦int୦float64(slice []int, function func(int,) float64,) []float64 {
	out := make([]float64, 0, len(slice))
	for _, v := range slice {
		out = append(out, function(v))
	}
	return out
}

//line apply.go2:39
func instantiate୦୦Choose୦int(slice []int, function func(int,) bool) []int {
	return instantiate୦୦chooseOrDrop୦int(slice, function, false, true)
}

//line apply.go2:48
func instantiate୦୦Drop୦int(slice []int, function func(int,) bool) []int {
	return instantiate୦୦chooseOrDrop୦int(slice, function, false, false)
}
//line apply.go2:29
func instantiate୦୦ApplyInPlace୦int(slice []int, function func(int,) int,) {
	for i := range slice {
		slice[i] = function(slice[i])
	}
}
//line apply.go2:29
func instantiate୦୦ApplyInPlace୦string(slice []string, function func(string,) string,) {
	for i := range slice {
		slice[i] = function(slice[i])
	}
}

//line apply.go2:56
func instantiate୦୦ChooseInPlace୦string(pointerToSlice *[]string, function func(string,) bool) {
//line apply.go2:56
 instantiate୦୦chooseOrDropInPlace୦string(pointerToSlice, function, true)
//line apply.go2:58
}

//line apply.go2:64
func instantiate୦୦DropInPlace୦string(pointerToSlice *[]string, function func(string,) bool) {
//line apply.go2:64
 instantiate୦୦chooseOrDropInPlace୦string(pointerToSlice, function, false)
//line apply.go2:66
}

//line apply.go2:72
func instantiate୦୦chooseOrDrop୦int(slice []int, function func(int,) bool, inPlace, truth bool) []int {
	out := slice[:0]
	if !inPlace {
		out = make([]int, 0, len(slice))
	}

	for _, v := range slice {
		if function(v) == truth {
			out = append(out, v)
		}
	}

	return out
}
//line apply.go2:68
func instantiate୦୦chooseOrDropInPlace୦string(slice *[]string, function func(string,) bool, truth bool) {
	*slice = instantiate୦୦chooseOrDrop୦string(*slice, function, true, truth)
}

func instantiate୦୦chooseOrDrop୦string(slice []string, function func(string,) bool, inPlace, truth bool) []string {
	out := slice[:0]
	if !inPlace {
		out = make([]string, 0, len(slice))
	}

	for _, v := range slice {
		if function(v) == truth {
			out = append(out, v)
		}
	}

	return out
}

//line apply.go2:85
var _ = reflect.Append
//line apply.go2:85
var _ = testing.AllocsPerRun
