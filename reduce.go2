// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package filter

// Reduce computes the reduction of the pair function across the elements of
// the slice. (If the types of the slice and function do not correspond, Reduce
// panics.) For instance, if the slice contains successive integers starting at
// 1 and the function is multiply, the result will be the factorial function.
// If the slice is empty, Reduce returns zero; if it has only one element, it
// returns that element. The return value must be type-asserted by the caller
// back to the element type of the slice. Example:
//	func multiply(a, b int) int { return a*b }
//	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
//	factorial := Reduce(a, multiply, 1).(int)
func Reduce(type T)(slice []T, pairFunction func(T, T) T, zero T) T {
	switch len(slice) {
	case 0:
		return zero
	case 1:
		return slice[0]
	}

	// Do the first two by hand to prime the pump.
	out := pairFunction(slice[0], slice[1])

	// Run from index 2 to the end.
	for i := 2; i < len(slice); i++ {
		out = pairFunction(out, slice[i])
	}
	return out
}
